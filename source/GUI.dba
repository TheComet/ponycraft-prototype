rem ---------------------------------------------------------------------------
rem GUI - handles the grahpical user interface
rem ---------------------------------------------------------------------------

remstart
	 This file is part of PonyCraft - Tainted Skies (prototype)

    PonyCraft - Tainted Skies (prototype) is free software: you can
	 redistribute it and/or modify it under the terms of the
	 GNU General Public License as published by the Free Software
	 Foundation, either version 3 of the License, or (at your option)
	 any later version.

    PonyCraft - Tainted Skies (prototype) is distributed in the hope
	 that it will be useful, but WITHOUT ANY WARRANTY; without even
	 the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
	 PURPOSE.  See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with PonyCraft - Tainted Skies (prototype). If not, see
	 <http://www.gnu.org/licenses/>.
remend

rem ---------------------------------------------------------------------------
rem Constants
rem ---------------------------------------------------------------------------

#constant GUIBindUnitMax 500

#constant GUICLICK_NOT_CLICKED		0
#constant GUICLICK_CLICKED				1

rem ---------------------------------------------------------------------------
rem User Defined Types
rem ---------------------------------------------------------------------------

type ButtonVT
   Clicked                          			as integer
endtype

type GUIVT
	logging                          			as integer
	Mouse3DInvalid                				as integer
	CurrentMax											as integer
	CurrentFrameMax									as integer
	CurrentFrameCountMax								as integer
	CurrentUnitBindMax								as integer
	ButtonClicked										as integer
	ButtonReleased										as integer
	ButtonActivateAbility							as integer
	ButtonCancelAbility								as integer
	SplashObj											as integer
	SplashImg											as integer
	SplashFillObj										as integer
	
	PortraitPos											as vec2
	InfoPanelPos										as vec2
	InfoPanelDescriptionPos							as vec2
	HealthPos											as vec2
	ManaPos												as vec2
	ShieldPos											as vec2
	MiniatureGridStartPos							as vec2
	MiniatureGridEndPos								as vec2
	MiniatureGridSize									as vec2
endtype

type GUIAT
	Active                           			as integer
	IMG                              			as word
	GlowIMG                          			as word
	PressIMG                         			as word
	LockedIMG                        			as word
	IconIMG												as word
	HotKeyIMG											as word
	KeyBind                          			as byte
	KeyBindFlag											as integer
	ID														as integer
	ToggleMode											as integer
	KeepLastImage										as integer
	
	Locked                           			as integer
	Hidden												as integer
	ClickState											as integer
	BindCount                        			as integer
	
	ButtonIconDiffuseNormal							as dword
	ButtonIconDiffuseGlow							as dword
	ButtonIconDiffusePress							as dword
	ButtonIconDiffuseLocked							as dword
	
	EventClickActive									as integer
	EventClickScript									as integer
	EventClickLine										as integer
	EventReleaseActive								as integer
	EventReleaseScript								as integer
	EventReleaseLine									as integer
	
	BindKeyPressed                   			as integer
	Ability                          			as integer
endtype

type GUIFrameAAT
	Active												as integer
	pos													as vec2
	EndPos												as vec2
	IMG													as integer
	SPR													as integer
	FrameCount											as integer
	CurrentFrame										as integer
	FrameDelayDefault									as integer
	FrameDelay											as integer
	FrameDelayCounter									as integer
endtype

rem ---------------------------------------------------------------------------
rem Initialise
rem ---------------------------------------------------------------------------

function InitGUI()
	
	rem local variables
	local g 												as integer
	local b 												as integer

	rem debug
	DebugOutput( 0 , "Initialising GUI" , DEBUG_NORMAL )

	rem ---------------------------------------------------------------------------
	rem Global Variables
   rem ---------------------------------------------------------------------------

	global uGUI                       			as GUIVT
	global Button                    			as ButtonVT

	rem ---------------------------------------------------------------------------
	rem Global Arrays
	rem ---------------------------------------------------------------------------
	
	global dim GUI()									as GUIAT
	global dim GUIFrame()							as GUIFrameAAT
	global dim GUIBindUnit() 						as integer
	
	Button.Clicked = -1
	uGUI.CurrentMax = -1
	uGUI.CurrentFrameMax = -1
	uGUI.CurrentFrameCountMax = 0
	uGUI.CurrentUnitBindMax = -1
	
	rem initialise other GUI elements
	InitGUIDragBox()

endfunction

function GUIAddStaticImage( ID , x , y , Filename$ )
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIAddStaticImage " + str$(ID) + "," + str$(x) + "," + str$(y) + chr$(34) + Filename$ + chr$(34) )
	
	rem local variable
	local n as integer
	
	rem make sure ID doesn't already exist
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).Active > 1
			if GUI( n ).ID = ID
				AddTextToConsole( 3 , "ID already in use!" )
				exitfunction -1
			endif
		endif
	next n
	
	rem find free slot
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).Active < 2 then exit
	next n
	
	rem no free slot, create
	if n = uGUI.CurrentMax + 1
		array insert at bottom GUI()
		inc uGUI.CurrentMax
	endif

	rem add frame and image
	GUI( n ).IMG = GUICreateFrame( GetRealScreenX( x ) , GetRealScreenY( y ) )
	GUIAddFrame( GUI( n ).IMG , Filename$ , -1 )

	rem set values
	GUI( n ).Active = 2
	GUI( n ).BindCount = -1
	GUI( n ).Locked = 0
	GUI( n ).Hidden = 0
	GUI( n ).ToggleMode = 0
	GUI( n ).EventClickActive = 0
	GUI( n ).EventReleaseActive = 0
	GUI( n ).Ability = 0
	GUI( n ).ID = ID
	
endfunction n

function GUICreateFrame( x , y )
	
	rem local variables
	local n as integer
	
	rem find free slot
	for n = 0 to uGUI.CurrentFrameMax
		if GUIFrame( n , 0 ).Active < 0 then exit
	next n
	
	rem none found, allocate space
	if n = uGUI.CurrentFrameMax + 1
		inc uGUI.CurrentFrameMax
		dim GUIFrame( uGUI.CurrentFrameMax , uGUI.CurrentFrameCountMax ) as GUIFrameAAT
	endif
	
	rem set parameters
	GUIFrame( n , 0 ).Active = 2
	GUIFrame( n , 0 ).FrameCount = -1
	GUIFrame( n , 0 ).CurrentFrame = 0
	GUIFrame( n , 0 ).FrameDelayDefault = 0
	GUIFrame( n , 0 ).pos.x = x
	GUIFrame( n , 0 ).pos.y = y
	GUIFrame( n , 0 ).SPR = 0
	
endfunction n

function GUIAddFrame( n , Filename$ , delay )
	
	rem make sure file exists
	if file exist( Filename$ ) = 0
		AddTextToConsole( 3 , "File " + chr$(34) + Filename$ + chr$(34) + " does not exist!" )
		exitfunction -1
	endif
	
	rem allocate space
	inc GUIFrame( n , 0 ).FrameCount
	if GUIFrame( n , 0 ).FrameCount > uGUI.CurrentFrameCountMax
		inc uGUI.CurrentFrameCountMax
		dim GUIFrame( uGUI.CurrentFrameMax , uGUI.CurrentFrameCountMax ) as GUIFrameAAT
	endif
	
	rem add frame
	GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).IMG = LoadImage( Filename$ , 1 )
	
	rem scale to fit screen resolution
	ik resize image GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).IMG , (image width( GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).IMG ) * uScreen.sc_wx) / 1600.0 , (image height( GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).IMG) * uScreen.sch) / 1200.0 , 1
	
	rem sprite it
	if GUIFrame( n , 0 ).SPR = 0 then GUIFrame( n , 0 ).SPR = find free sprite()
	if sprite exist( GUIFrame( n , 0 ).SPR )
		repeat
			set cursor 0,0
			print "HOLY SHIT"
			print n
			paste image GUIFrame( n , 0 ).IMG , 300 , 0 , 1
			sync
		until returnkey()
		repeat:until returnkey()=0
	endif
	sprite GUIFrame( n , 0 ).SPR , GUIFrame( n , 0 ).pos.x , GUIFrame( n , 0 ).pos.y , GUIFrame( n , 0 ).IMG
	
	rem use default delay if necessary
	if delay = -1 then delay = GUIFrame( n , 0 ).FrameDelayDefault
	
	rem set end positions
	GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).pos.x = GUIFrame( n , 0 ).pos.x
	GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).pos.y = GUIFrame( n , 0 ).pos.y
	GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).EndPos.x = GUIFrame( n , 0 ).pos.x + image width( GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).IMG )
	GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).EndPos.y = GUIFrame( n , 0 ).pos.y + image height( GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).IMG )
	GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).FrameDelay = delay
	
endfunction n

function GUIDestroyFrame( n )
	
	rem make sure in range
	if n < 0 or n > uGUI.CurrentFrameMax then exitfunction
	if GUIFrame( n , 0 ).Active < 2 then exitfunction
	
	rem destroy
	if GUIFrame( n , 0 ).SPR > 0
		if sprite exist( GUIFrame( n , 0 ).SPR ) then delete sprite GUIFrame( n , 0 ).SPR
		GUIFrame( n , 0 ).SPR = 0
	endif
	
	rem delete images
	for s = 0 to GUIFrame( n , 0 ).FrameCount
		if image exist( GUIFrame( n , s ).IMG ) then delete image GUIFrame( n , s ).IMG
	next s
		
	GUIFrame( n , 0 ).Active = 0
	
endfunction

function GUIPositionFrame( n , x , y )
	
	rem re-sprite
	if GUIFrame( n , 0 ).FrameCount > -1
		sprite GUIFrame( n , 0 ).SPR , x , y , GUIFrame( n , GUIFrame( n , 0 ).CurrentFrame ).IMG
	endif
	
	rem set positions
	GUIFrame( n , 0 ).pos.x = x
	GUIFrame( n , 0 ).pos.y = y
	GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).EndPos.x = GUIFrame( n , 0 ).pos.x + image width( GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).IMG )
	GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).EndPos.x = GUIFrame( n , 0 ).pos.x + image height( GUIFrame( n , GUIFrame( n , 0 ).FrameCount ).IMG )
	
endfunction

function GUIShowFrame( n )
	
	rem show sprite
	if GUIFrame( n , 0 ).SPR > 0
		if sprite exist( GUIFrame( n , 0 ).SPR )
			show sprite GUIFrame( n , 0 ).SPR
		endif
	endif
		
endfunction

function GUIHideFrame( n )
	
	rem hide sprite
	if GUIFrame( n , 0 ).SPR > 0
		if sprite exist( GUIFrame( n , 0 ).SPR )
			hide sprite GUIFrame( n , 0 ).SPR
		endif
	endif
	
endfunction

function GUIGetFrameStartX( n )
	if GUIFrame( n , 0 ).FrameCount = -1 then exitfunction 0
	result = GUIFrame( n , GUIFrame( n , 0 ).CurrentFrame ).pos.x
endfunction result

function GUIGetFrameEndX( n )
	if GUIFrame( n , 0 ).FrameCount = -1 then exitfunction 0
	result = GUIFrame( n , GUIFrame( n , 0 ).CurrentFrame ).EndPos.x
endfunction result

function GUIGetFrameStartY( n )
	if GUIFrame( n , 0 ).FrameCount = -1 then exitfunction 0
	result = GUIFrame( n , GUIFrame( n , 0 ).CurrentFrame ).pos.y
endfunction result

function GUIGetFrameEndY( n )
	if GUIFrame( n , 0 ).FrameCount = -1 then exitfunction 0
	result = GUIFrame( n , GUIFrame( n , 0 ).CurrentFrame ).EndPos.y
endfunction result

function GUISetFrameDiffuse( n , diffuse )
	if GUIFrame( n , 0 ).FrameCount = -1 then exitfunction
	set sprite diffuse GUIFrame( n , 0 ).SPR , rgbr( diffuse ) , rgbg( diffuse ) , rgbb( diffuse )
endfunction

function GUIAddStaticFrame( ID , Filename$ , delay )
	
	rem local variables
	local n as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 2
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add the frame
	GUIAddFrame( GUI( n ).IMG , Filename$ , delay )
	
endfunction n

function GUIAddButtonNormalFrame( ID , Filename$ , delay )
	
	rem local variables
	local n as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add the frame
	GUIAddFrame( GUI( n ).IMG , Filename$ , delay )
	
endfunction n

function GUIAddButtonMouseOverFrame( ID , Filename$ , delay )
	
	rem local variables
	local n as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add the frame
	GUIAddFrame( GUI( n ).GlowIMG , Filename$ , delay )
	
endfunction n

function GUIAddButtonPressFrame( ID , Filename$ , delay )
	
	rem local variables
	local n as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add the frame
	GUIAddFrame( GUI( n ).PressIMG , Filename$ , delay )
	
endfunction n

function GUIAddButtonLockedFrame( ID , Filename$ , delay )
	
	rem local variables
	local n as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add the frame
	GUIAddFrame( GUI( n ).LockedIMG , Filename$ , delay )
	
endfunction n

function GUIAddButtonIconFrame( ID , Filename$ , delay )
	
	rem local variables
	local n as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add the frame
	GUIAddFrame( GUI( n ).IconIMG , Filename$ , delay )
	
endfunction n

function GUISetStaticFrameDelayDefault( ID , delay )
	
	rem local variables
	local n as integer
	local s as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add delay
	s = GUI( n ).IMG
	GUIFrame( s , 0 ).FrameDelayDefault = delay
	for n = 0 to GUIFrame( s , 0 ).FrameCount
		GUIFrame( s , n ).FrameDelay = delay
	next n
	
endfunction n

function GUISetButtonNormalFrameDelayDefault( ID , delay )
	
	rem local variables
	local n as integer
	local s as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add delay
	s = GUI( n ).IMG
	GUIFrame( s , 0 ).FrameDelayDefault = delay
	for n = 0 to GUIFrame( s , 0 ).FrameCount
		GUIFrame( s , n ).FrameDelay = delay
	next n
	
endfunction n

function GUISetButtonMouseOverFrameDelayDefault( ID , delay )
	
	rem local variables
	local n as integer
	local s as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add delay
	s = GUI( n ).GlowIMG
	GUIFrame( s , 0 ).FrameDelayDefault = delay
	for n = 0 to GUIFrame( s , 0 ).FrameCount
		GUIFrame( s , n ).FrameDelay = delay
	next n
	
endfunction n

function GUISetButtonPressFrameDelayDefault( ID , delay )
	
	rem local variables
	local n as integer
	local s as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add delay
	s = GUI( n ).PressIMG
	GUIFrame( s , 0 ).FrameDelayDefault = delay
	for n = 0 to GUIFrame( s , 0 ).FrameCount
		GUIFrame( s , n ).FrameDelay = delay
	next n
	
endfunction n

function GUISetButtonLockedFrameDelayDefault( ID , delay )
	
	rem local variables
	local n as integer
	local s as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add delay
	s = GUI( n ).LockedIMG
	GUIFrame( s , 0 ).FrameDelayDefault = delay
	for n = 0 to GUIFrame( s , 0 ).FrameCount
		GUIFrame( s , n ).FrameDelay = delay
	next n
	
endfunction n

function GUISetButtonIconFrameDelayDefault( ID , delay )
	
	rem local variables
	local n as integer
	local s as integer
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem add delay
	s = GUI( n ).IconIMG
	GUIFrame( s , 0 ).FrameDelayDefault = delay
	for n = 0 to GUIFrame( s , 0 ).FrameCount
		GUIFrame( s , n ).FrameDelay = delay
	next n
	
endfunction n

function GUIDestroyElement( ID )
	
	rem local variables
	local n as integer
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIDestroyElement " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem not active
	if GUI( n ).Active < 2
		AddTextToConsole( 3 , "GUI ID not active!" )
		exitfunction -1
	endif
	
	rem unbind anything from it
	for b = 0 to GUI( n ).BindCount
		GUIBindUnit( n , b ) = -1
	next b
	GUI( n ).BindCount = -1
	
	rem destroy
	GUIDestroyFrame( GUI( n ).IMG )
	GUIDestroyFrame( GUI( n ).GlowIMG )
	GUIDestroyFrame( GUI( n ).PressIMG )
	GUIDestroyFrame( GUI( n ).LockedIMG )
	GUIDestroyFrame( GUI( n ).IconIMG )
	GUIDestroyFrame( GUI( n ).HotKeyIMG )
	GUI( n ).Active = 0
	
endfunction n

function GUIAddButton( ID , x , y , KeyBind , BackFilename$ , GlowFilename$ , PressFilename$ , LockedFilename$ , IconFilename$ , KeepLastImage )
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIAddButton " + str$(ID) + "," + str$(x) + "," + str$(y) + "," + str$(KeyBind) + chr$(34) + BackFilename$ + chr$(34) + "," + chr$(34) + GlowFilename$ + chr$(34) + "," + chr$(34) + PressFilename$ + chr$(34) + "," + chr$(34) + LockedFilename$ + chr$(34) )
		
	rem local variables
	local n as integer
	
	rem make sure ID doesn't already exist
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).Active > 1
			if GUI( n ).ID = ID
				AddTextToConsole( 3 , "ID already in use!" )
				exitfunction -1
			endif
		endif
	next n
	
	rem find free slot
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).Active < 2 then exit
	next n
	
	rem no free slot, create
	if n = uGUI.CurrentMax + 1
		array insert at bottom GUI()
		inc uGUI.CurrentMax
	endif
	
	rem create frames
	GUI( n ).IMG = GUICreateFrame( GetRealScreenX( x ) , GetRealScreenY( y ) )
	GUI( n ).GlowIMG = GUICreateFrame( GetRealScreenX( x ) , GetRealScreenY( y ) )
	GUI( n ).PressIMG = GUICreateFrame( GetRealScreenX( x ) , GetRealScreenY( y ) )
	GUI( n ).LockedIMG = GUICreateFrame( GetRealScreenX( x ) , GetRealScreenY( y ) )
	GUI( n ).IconIMG = GUICreateFrame( GetRealScreenX( x ) , GetRealScreenY( y ) )
	GUI( n ).HotKeyIMG = GUICreateFrame( GetRealScreenX( x ) , GetRealScreenY( y ) )
	GUIAddFrame( GUI( n ).IMG , BackFilename$ , -1 )
	GUIAddFrame( GUI( n ).GlowIMG , GlowFilename$ , -1 )
	GUIAddFrame( GUI( n ).PressIMG , PressFilename$ , -1 )
	GUIAddFrame( GUI( n ).LockedIMG , LockedFilename$ , -1 )
	GUIAddFrame( GUI( n ).IconIMG , IconFilename$ , -1 )
	
	rem allocate space for frame
	s = GUI( n ).HotKeyIMG
	inc GUIFrame( s , 0 ).FrameCount
	if GUIFrame( s , 0 ).FrameCount > uGUI.CurrentFrameCountMax
		inc uGUI.CurrentFrameCountMax
		dim GUIFrame( uGUI.CurrentFrameMax , uGUI.CurrentFrameCountMax ) as GUIFrameAAT
	endif
	
	rem add frame
	GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).IMG = find free image()
	create bitmap 1 , 16 , 16
	a2fillbox 0 , 0 , 15 , 15 , 0xFF0F0F0F
	a2text FontID , 1 , 0 , chr$( _GUI_Get_Character_From_Scancode_Switzerland( KeyBind ) ) , 0xFFFFFFFF
	get image GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).IMG , 0 , 0 , 16 , 16
	delete bitmap 1
	
	rem scale to fit screen resolution
	ik resize image GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).IMG , (image width( GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).IMG ) * uScreen.sc_wx) / 1600.0 , (image height( GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).IMG) * uScreen.sch) / 1200.0 , 1
	
	rem sprite it
	if GUIFrame( s , 0 ).SPR = 0 then GUIFrame( s , 0 ).SPR = find free sprite()
	sprite GUIFrame( s , 0 ).SPR , GUIFrame( s , 0 ).pos.x , GUIFrame( s , 0 ).pos.y , GUIFrame( s , 0 ).IMG

	rem set end positions
	GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).pos.x = GUIFrame( s , 0 ).pos.x
	GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).pos.y = GUIFrame( s , 0 ).pos.y
	GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).EndPos.x = GUIFrame( s , 0 ).pos.x + image width( GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).IMG )
	GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).EndPos.y = GUIFrame( s , 0 ).pos.y + image height( GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).IMG )
	GUIFrame( s , GUIFrame( s , 0 ).FrameCount ).FrameDelay = 0
	
	rem set values
	GUI( n ).Active = 3
	GUI( n ).Locked = 0
	GUI( n ).Hidden = 0
	GUI( n ).ToggleMode = 0
	GUI( n ).EventClickActive = 0
	GUI( n ).EventReleaseActive = 0
	GUI( n ).BindCount = -1
	GUI( n ).KeyBind = KeyBind
	GUI( n ).Ability = 0
	GUI( n ).ID = ID
	GUI( n ).KeepLastImage = KeepLastImage
	GUI( n ).ButtonIconDiffuseNormal = 0xFFFFFFFF
	GUI( n ).ButtonIconDiffuseGlow = 0xFFFFFFFF
	GUI( n ).ButtonIconDiffusePress = 0xFFFFFFFF
	GUI( n ).ButtonIconDiffuseLocked = 0xFFFFFFFF
	
endfunction n

function _GUI_Hide_Button_Frames( n )
	
	rem hide frames
	GUIHideFrame( GUI( n ).IMG )
	GUIHideFrame( GUI( n ).GlowIMG )
	GUIHideFrame( GUI( n ).PressIMG )
	GUIHideFrame( GUI( n ).LockedIMG )
	
endfunction

function GUILockButton( ID )
	
	rem local variables
	local n as integer
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUILockButton " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem lock
	GUI( n ).Locked = 1
	
endfunction n

function GUIUnlockButton( ID )
	
	rem local variables
	local n as integer
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIUnlockButton " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction -1
	endif
	
	rem unlock
	GUI( n ).Locked = 0

endfunction n

function GUIHideElement( ID )
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIHideEleemnt " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active < 2
		AddTextToConsole( 3 , "Not active!" )
		exitfunction -1
	endif
	
	rem hide
	GUI( n ).Hidden = 1
	
endfunction n

function GUIShowElement( ID )
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIShowElement " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active > 1
		AddTextToConsole( 3 , "Not active!" )
		exitfunction -1
	endif
	
	rem hide
	GUI( n ).Hidden = 0
	
endfunction n

function GUIButtonEnableToggle( ID )
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIButtonEnableToggle " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "Not active!" )
		exitfunction -1
	endif
	
	rem hide
	GUI( n ).ToggleMode = 1
	
endfunction n

function GUIButtonDisableToggle( ID )
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIButtonDisableToggle " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "Not active!" )
		exitfunction -1
	endif
	
	rem hide
	GUI( n ).ToggleMode = 0
	
endfunction n

function GUIBindButtonToUnit( ID , UnitID )
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIBindButtonToUnit " + str$(ID) + "," + str$(UnitID) )
	
	rem make sure unit is in range
	if UnitID < 0 or n > uUnit.CurrentMax
		AddTextToConsole( 3 , "Unit index not found!" )
		exitfunction -1
	endif
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure unit is active
	if Unit( UnitID ).Active < 2
		AddTextToConsole( 3 , "Unit not active!" )
		exitfunction -1
	endif
	
	rem make sure button is active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "Button not active!" )
		exitfunction -1
	endif

	rem find or create binding slot
	inc GUI( n ).BindCount
	if GUI( n ).BindCount > uGUI.CurrentUnitBindMax
		inc uGUI.CurrentUnitBindMax
		dim GUIBindUnit( uGUI.CurrentMax , uGUI.CurrentUnitBindMax ) as integer
	endif
	
	rem bind
	GUIBindUnit( n , GUI( n ).BindCount ) = UnitID
	
endfunction n

function GUIUnbindUnit( ID , UnitID )
	
	rem local variables
	local s as integer
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIUnbindUnit " + str$(ID) + "," + str$(UnitID) )
	
	rem make sure unit is in range
	if UnitID < 0 or UnitID > uUnit.CurrentMax
		AddTextToConsole( 3 , "Unit index not found!" )
		exitfunction -1
	endif
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem find index for bound unit
	for s = 0 to GUI( n ).BindCount
		if GUIBindUnit( n , s ) = UnitID then exit
	next s
	
	rem shift binding stack down
	if s < GUI( n ).BindCount + 1
		for UnitID = s + 1 to GUI( n ).BindCount
			GUIBindUnit( n , UnitID - 1 ) = GUIBindUnit( n , UnitID )
		next UnitID
		if GUI( n ).BindCount > -1 then dec GUI( n ).BindCount
	endif
	
	rem button is not clicked
	GUI( n ).ClickState = GUICLICK_NOT_CLICKED
	
endfunction n

function GUIPositionElement( ID , x , y )
	
	rem local variables
	local n as integer
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIPositionElement " + str$(ID) + "," + str$(x) + "," + str$(y) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction -1
	endif
	
	rem make sure active
	if GUI( n ).Active < 2
		AddTextToConsole( 3 , "GUI element not active!" )
		exitfunction -1
	endif
	
	rem reposition
	GUIPositionFrame( GUI( n ).IMG , GetRealScreenX( x ) , GetRealScreenY( y ) )
	
	rem buttons have additional frames
	if GUI( n ).Active = 3
		GUIPositionFrame( GUI( n ).GlowIMG , GetRealScreenX( x ) , GetRealScreenY( y ) )
		GUIPositionFrame( GUI( n ).PressIMG , GetRealScreenX( x ) , GetRealScreenY( y ) )
		GUIPositionFrame( GUI( n ).LockedIMG , GetRealScreenX( x ) , GetRealScreenY( y ) )
		GUIPositionFrame( GUI( n ).IconIMG , GetRealScreenX( x ) , GetRealScreenY( y ) )
	endif
	
endfunction n

function GUISetPortraitPosition( x , y )
	
	rem set
	uGUI.PortraitPos.x = GetRealScreenX( x )
	uGUI.PortraitPos.y = GetRealScreenY( y )
	
endfunction

function GUISetInfoPanelPosition( x , y )
	
	rem set
	uGUI.InfoPanelPos.x = GetRealScreenX( x )
	uGUI.InfoPanelPos.y = GetRealScreenY( y )
	
endfunction

function GUISetInfoPanelDescriptionPosition( x , y )
	
	rem set
	uGUI.InfoPanelDescriptionPos.x = GetRealScreenX( x )
	uGUI.InfoPanelDescriptionPos.y = GetRealScreenY( y )
	
endfunction

function GUISetInfoPanelHealthPosition( x , y )
	
	rem set
	uGUI.HealthPos.x = GetRealScreenX( x )
	uGUI.HealthPos.y = GetRealScreenY( y )

endfunction

function GUISetInfoPanelManaPosition( x , y )
	
	rem set
	uGUI.ManaPos.x = GetRealScreenX( x )
	uGUI.ManaPos.y = GetRealScreenY( y )
	
endfunction

function GUISetInfoPanelShieldPosition( x , y )
	
	rem set
	uGUI.ShieldPos.x = GetRealScreenX( x )
	uGUI.ShieldPos.y = GetRealScreenY( y )
	
endfunction

function GUISetMiniatureGrid( sx , sy , ex , ey , gridSizeX , gridSizeY )
	
	rem set
	uGUI.MiniatureGridStartPos.x = GetRealScreenX( sx )
	uGUI.MiniatureGridStartPos.y = GetRealScreenY( sy )
	uGUI.MiniatureGridEndPos.x = GetRealScreenX( ex )
	uGUI.MiniatureGridEndPos.y = GetRealScreenY( ey )
	uGUI.MiniatureGridSize.x = GetRealScreenX( gridSizeX )
	uGUI.MiniatureGridSize.y = GetRealScreenY( gridSizeY )
	
endfunction

function GUIButtonSetIconDiffuseOnNormal( ID , diffuse )
	
	rem local variables
	local n as integer
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIUnlockButton " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction
	endif
	
	rem set value
	GUI( n ).ButtonIconDiffuseNormal = diffuse

endfunction

function GUIButtonSetIconDiffuseOnGlow( ID , diffuse )
	
	rem local variables
	local n as integer
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIUnlockButton " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction
	endif
	
	rem set value
	GUI( n ).ButtonIconDiffuseGlow = diffuse

endfunction

function GUIButtonSetIconDiffuseOnPress( ID , diffuse )
	
	rem local variables
	local n as integer
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIUnlockButton " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction
	endif
	
	rem set value
	GUI( n ).ButtonIconDiffusePress = diffuse

endfunction

function GUIButtonSetIconDiffuseOnLocked( ID , diffuse )
	
	rem local variables
	local n as integer
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "GUIUnlockButton " + str$(ID) )
	
	rem find ID of GUI element
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).ID = ID then exit
	next n
	
	rem not found
	if n = uGUI.CurrentMax + 1
		AddTextToConsole( 3 , "GUI ID not found!" )
		exitfunction
	endif
	
	rem make sure active
	if GUI( n ).Active <> 3
		AddTextToConsole( 3 , "GUI element not in correct state!" )
		exitfunction
	endif
	
	rem set value
	GUI( n ).ButtonIconDiffuseLocked = diffuse
	
endfunction

function GUICreateSplash( imgFile$ )
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "CreateSplash" )
	
	rem make sure file exists
	if file exist( imgFile$ ) = 0
		AddTextToConsole( 3 , "File " + chr$(34) + imgfile$ + chr$(34) + " does not exist" )
		exitfunction
	endif

   rem if not created, create
   if uGUI.SplashObj = 0
      uGUI.SplashObj = find free object()
		uGUI.SplashImg = find free image()
      make object plain uGUI.SplashObj , 16 , 12
      lock object on uGUI.SplashObj
      position object uGUI.SplashObj , 0 , 0 , 10
		load image imgFile$ , uGUI.SplashImg
      texture object uGUI.SplashObj , uGUI.SplashImg
		set object light uGUI.SplashObj , 0
		uGUI.SplashFillObj = find free object()
		make object plain uGUI.SplashFillObj , 500 , 500
		lock object on uGUI.SplashFillObj
		position object uGUI.SplashFillObj , 0 , 0 , 11
		set object light uGUI.SplashFillObj , 0
		texture object uGUI.SplashFillObj , IMGBlack
   endif
	
	rem refresh screen so it appears
	sync
	sync

endfunction

function GUIDestroySplash()
	
	rem logging
	if uGUI.logging = 1 then AddTextToConsole( 0 , "DestroySplash" )

   rem destroy splash object
	if uGUI.SplashObj > 0
		delete object uGUI.SplashObj
		delete image uGUI.SplashImg
		delete object uGUI.SplashFillObj
		uGUI.SplashObj = 0
	endif

endfunction

function ControlGUI()
	
	rem control drag box
	ControlGUIDragBox()
	
	rem local variables
   local n as integer
	local u as integer
	local a as integer
	local success as integer

	rem reset some values
	uGUI.ButtonClicked = -1
	uGUI.ButtonReleased = -1
	uGUI.Mouse3DInvalid = 0
	uGUI.ButtonActivateAbility = -1
	uGUI.ButtonCancelAbility = -1
	
	rem loop through all active 
   for n = 0 to uGUI.CurrentMax
		
		rem static image
		if GUI( n ).Active = 2
			
			rem check if 3D mouse is invalid
			if uMouse.x > GUIGetFrameStartX( n ) and uMouse.x < GUIGetFrameEndX( n )
				if uMouse.y > GUIGetFrameStartY( n ) and uMouse.y < GUIGetFrameEndY( n ) then uGUI.Mouse3DInvalid = 1
			endif
			
		endif
		
		rem button
		if GUI( n ).Active = 3
			
			rem If button is not bound to any units, button will act like a normal menu button
			rem if button is bound to units, the button is shown/hidden according to the current units selected
			rem and according to the ability's settings its bound to
			if GUI( n ).BindCount = -1
				
				rem draw and control input
				_GUI_DrawAndControlButtons( n , 0 )
				
			rem button is bound to units
			else
			
				rem default
				GUI( n ).Locked = 1
				GUI( n ).Hidden = 1
			
				rem loop through all selected units and find bound button
				for s = 0 to uUnit.CurrentMax
					if Unit( s ).Active > 1
						if Unit( s ).Selected > 1
							
							rem check if button is bound to unit
							for r = 0 to GUI( n ).BindCount
								if GUIBindUnit( n , r ) = s then exit
							next r
							
							rem found
							if r < GUI( n ).BindCount + 1 then exit
							
						endif
					endif
				next s
				
				rem found
				if s < uUnit.CurrentMax + 1
					
					rem find ability
					for r = 0 to MaxUnitAbility
						if UnitAbility( s , r ).Active > 0 and UnitAbility( s , r ).BindButton = n then exit
					next r
					if r < MaxUnitAbility + 1
												
						rem copy settings to GUI button
						rem only lock or hide ability if all units have it locked or hidden
						for s = 0 to uUnit.CurrentMax
							if Unit( s ).Active > 1
								if Unit( s ).Selected > 1
									
									rem check if ability is bound to button
									for r = 0 to MaxUnitAbility
										if UnitAbility( s , r ).Active > 0
											if UnitAbility( s , r ).BindButton = n then exit
										endif
									next r
									
									rem found
									if r < MaxUnitAbility + 1
										
										rem copy ability settings to button
										if UnitAbility( s , r ).LockButton = 0 and Unit( s ).Stats.CurrentMana# >= UnitAbility( s , r ).ManaDrain# then GUI( n ).Locked = 0
										if UnitAbility( s , r ).HideButton = 0 then GUI( n ).Hidden = 0
										
									endif
									
									rem no need to carry on
									if GUI( n ).Locked = 0 and GUI( n ).Hidden = 0 then exit
								
								endif
							endif
						next s
						
					endif
				endif
				
				rem draw and control input
				_GUI_DrawAndControlButtons( n , 1 )
						
			endif

		endif
	next n
	
	rem if mouse is on minimap, calculate 3D coordinates
	uMouse.OnMinimap = 0
	for n = 0 to uMinimap.CurrentMax
		if Minimap( n ).Active > 1
			if uMouse.x > Minimap( n ).StartPos.x and uMouse.x < Minimap( n ).EndPos.x
				if uMouse.y > Minimap( n ).StartPos.y and uMouse.y < Minimap( n ).EndPos.y
					
					rem convert to XZ
					x# = uMouse.y-Minimap( n ).StartPos.y : rem cast to float
					uMouse.Click3D.x# = (uMouse.x-Minimap( n ).StartPos.x) * (Minimap( n ).WorldEndPos.x# - Minimap( n ).WorldStartPos.x#) / Minimap( n ).Size.x + Minimap( n ).WorldStartPos.x#
					uMouse.Click3D.z# = (1.0 - (x# / Minimap( n ).Size.y)) * (Minimap( n ).WorldEndPos.z# - Minimap( n ).WorldStartPos.z#) + Minimap( n ).WorldStartPos.z#
					uMouse.OnMinimap = 1
					
					rem find ground height
					if SC_RayCastGroup( COL_TERRAIN , uMouse.Click3D.x# , 200 , uMouse.Click3D.z# , uMouse.Click3D.x# , -200 , uMouse.Click3D.z# , 0 )
						uMouse.Click3D.y# = SC_GetStaticCollisionY()
					endif
				
				endif
			endif
		endif
	next n
	
	rem call events
	if uGUI.ButtonClicked > -1
		if GUI( uGUI.ButtonClicked ).EventClickActive = 1
			CallEvent( GUI( uGUI.ButtonClicked ).EventClickScript , GUI( uGUI.ButtonClicked ).EventClickLine )
		endif
	endif
	if uGUI.ButtonReleased > -1
		if GUI( uGUI.ButtonReleased ).EventReleaseActive = 1
			CallEvent( GUI( uGUI.ButtonReleased ).EventReleaseScript , GUI( uGUI.ButtonReleased ).EventReleaseLine )
		endif
	endif

endfunction

function _GUI_DrawAndControlButtons( n , ManualPress )

	rem button is not hidden
	if GUI( n ).Hidden = 0
		
		rem show icon (isn't changed unless button is hidden)
		GUIShowFrame( GUI( n ).IconIMG )
		GUIShowFrame( GUI( n ).HotKeyIMG )
		
		rem button is locked
		if GUI( n ).Locked = 1
			
			rem draw locked image
			if GUI( n ).KeepLastImage = 0
				_GUI_Hide_Button_Frames( n )
			endif
			GUIShowFrame( GUI( n ).LockedIMG )
			GUISetFrameDiffuse( GUI( n ).IconIMG , GUI( n ).ButtonIconDiffuseLocked )
		
		rem button is not locked
		else
		
			rem button is currently not being pressed
			if GUI( n ).ClickState = GUICLICK_NOT_CLICKED
				
				rem mouse is over button
				if uMouse.x > GUIGetFrameStartX( GUI( n ).IMG ) and uMouse.x < GUIGetFrameEndX( GUI( n ).IMG ) and uMouse.y > GUIGetFrameStartY( GUI( n ).IMG ) and uMouse.y < GUIGetFrameEndY( GUI( n ).IMG )
					
					rem sprite glow image
					if GUI( n ).KeepLastImage = 0
						_GUI_Hide_Button_Frames( n )
					endif
					GUIShowFrame( GUI( n ).GlowIMG )
					GUISetFrameDiffuse( GUI( n ).IconIMG , GUI( n ).ButtonIconDiffuseGlow )
										
					rem Mouse clicks button
					if uMouse.click = 1
						_GUI_ReleaseOtherButtons()
						if ManualPress = 0 then GUI( n ).ClickState = GUICLICK_CLICKED
						uGUI.ButtonClicked = n
						
						rem sprite press image
						if GUI( n ).KeepLastImage = 0
							_GUI_Hide_Button_Frames( n )
						endif
						GUIShowFrame( GUI( n ).PressIMG )
						GUISetFrameDiffuse( GUI( n ).IconIMG , GUI( n ).ButtonIconDiffusePress )
																		
					endif
					
					rem 3D mouse is invalid
					uGUI.Mouse3DInvalid = 1
					
				rem mouse is not over button
				else
				
					rem show normal image
					_GUI_Hide_Button_Frames( n )
					GUIShowFrame( GUI( n ).IMG )
					GUISetFrameDiffuse( GUI( n ).IconIMG , GUI( n ).ButtonIconDiffuseNormal )
					
				endif
				
				rem bind key presses
				if keystate( GUI( n ).KeyBind ) and GUI( n ).KeyBindFlag = 0
					_GUI_ReleaseOtherButtons()
					GUI( n ).KeyBindFlag = 1
					if ManualPress = 0 then GUI( n ).ClickState = GUICLICK_CLICKED
					uGUI.ButtonClicked = n
					
					rem sprite press image
					if GUI( n ).KeepLastImage = 0
						_GUI_Hide_Button_Frames( n )
					endif
					GUIShowFrame( GUI( n ).GlowIMG )
					GUIShowFrame( GUI( n ).PressIMG )
					GUISetFrameDiffuse( GUI( n ).IconIMG , GUI( n ).ButtonIconDiffusePress )

				endif
				if keystate( GUI( n ).KeyBind ) = 0 then GUI( n ).KeyBindFlag = 0
				
			rem button is being pressed
			else
			
				rem toggle mode is activated
				if GUI( n ).ToggleMode = 1
					
					rem mouse is over button
					if uMouse.x > GUIGetFrameStartX( GUI( n ).IMG ) and uMouse.x < GUIGetFrameEndX( GUI( n ).IMG ) and uMouse.y > GUIGetFrameStartY( GUI( n ).IMG ) and uMouse.y < GUIGetFrameEndY( GUI( n ).IMG )
						if GUI( n ).KeepLastImage = 0
							_GUI_Hide_Button_Frames( n )
						endif
						GUIShowFrame( GUI( n ).PressIMG )
						GUISetFrameDiffuse( GUI( n ).IconIMG , GUI( n ).ButtonIconDiffusePress )

						rem Mouse clicks button
						if uMouse.click = 1
							if ManualPress = 0 then GUI( n ).ClickState = GUICLICK_NOT_CLICKED
							uGUI.ButtonReleased = n
						endif
						
						rem 3D mouse is invalid
						uGUI.Mouse3DInvalid = 1
						
					rem mouse is not over button
					else
					
						rem paste pressed image
						if GUI( n ).KeepLastImage = 0
							_GUI_Hide_Button_Frames( n )
						endif
						GUIShowFrame( GUI( n ).PressIMG )
						GUISetFrameDiffuse( GUI( n ).IconIMG , GUI( n ).ButtonIconDiffusePress )
						
					endif
					
					rem bind key presses
					if keystate( GUI( n ).KeyBind ) and GUI( n ).KeyBindFlag = 0
						GUI( n ).KeyBindFlag = 1
						if ManualPress = 0 then GUI( n ).ClickState = GUICLICK_NOT_CLICKED
						uGUI.ButtonReleased = n
					endif
					if keystate( GUI( n ).KeyBind ) = 0 then GUI( n ).KeyBindFlag = 0
					
				rem toggle mode is not activated
				else
				
					rem button is being pressed
					if GUI( n ).KeepLastImage = 0
						_GUI_Hide_Button_Frames( n )
					endif
					GUIShowFrame( GUI( n ).GlowIMG )
					GUIShowFrame( GUI( n ).PressIMG )
					GUISetFrameDiffuse( GUI( n ).IconIMG , GUI( n ).ButtonIconDiffusePress )
					
					rem release button if mouse is no longer clicking
					if uMouse.click <> 2 and keystate( GUI( n ).KeyBind ) = 0
						if ManualPress = 0 then GUI( n ).ClickState = GUICLICK_NOT_CLICKED
						uGUI.ButtonReleased = n
					endif
					
					rem activate an ability if mouse is clicked
					if uMouse.click = 1
						uGUI.ButtonActivateAbility = n
					endif
					
					rem cancel an ability
					if uMouse.click = 4
						uGUI.ButtonCancelAbility = n
					endif
					
				endif
			endif
						
		endif
		
	rem button is hidden
	else
	
		_GUI_Hide_Button_Frames( n )
		GUIHideFrame( GUI( n ).IconIMG )
		GUIHideFrame( GUI( n ).HotKeyIMG )
	
	endif

endfunction

function GUIUpdateFrame()
	
	rem local variables
	local n as integer
	
	rem loop through all active frames
	for n = 0 to uGUI.CurrentFrameMax
		if GUIFrame( n , 0 ).Active = 2
			if GUIFrame( n , 0 ).FrameCount > -1
						
				rem update frame
				inc GUIFrame( n , 0 ).FrameDelayCounter
				if GUIFrame( n , 0 ).FrameDelayCounter > GUIFrame( n , GUIFrame( n ).CurrentFrame ).FrameDelay
					GUIFrame( n , 0 ).FrameDelayCounter = 0
					inc GUIFrame( n , 0 ).CurrentFrame
					if GUIFrame( n , 0 ).CurrentFrame > GUIFrame( n , 0 ).FrameCount then GUIFrame( n , 0 ).CurrentFrame = 0
					sprite GUIFrame( n , 0 ).SPR , GUIFrame( n , 0 ).pos.x , GUIFrame( n , 0 ).pos.y , GUIFrame( n , GUIFrame( n , 0 ).CurrentFrame ).IMG
				endif
			
			endif
		endif
	next n
	
endfunction

function _GUI_ReleaseOtherButtons()
	
	rem release any clicked buttons
	for n = 0 to uGUI.CurrentMax
		if GUI( n ).Active = 3
			GUI( n ).ClickState = GUICLICK_NOT_CLICKED
		endif
	next n
	
endfunction

function _GUI_Get_Character_From_Scancode_Switzerland( scan )

	rem lookup table
	if scan = 16 then exitfunction asc( "Q" )
	if scan = 17 then exitfunction asc( "W" )
	if scan = 18 then exitfunction asc( "E" )
	if scan = 19 then exitfunction asc( "R" )
	if scan = 20 then exitfunction asc( "T" )
	if scan = 21 then exitfunction asc( "Z" )
	if scan = 22 then exitfunction asc( "U" )
	if scan = 23 then exitfunction asc( "I" )
	if scan = 24 then exitfunction asc( "O" )
	if scan = 25 then exitfunction asc( "P" )
	if scan = 26 then exitfunction asc( "Ü" )
	if scan = 30 then exitfunction asc( "A" )
	if scan = 31 then exitfunction asc( "S" )
	if scan = 32 then exitfunction asc( "D" )
	if scan = 33 then exitfunction asc( "F" )
	if scan = 34 then exitfunction asc( "G" )
	if scan = 35 then exitfunction asc( "H" )
	if scan = 36 then exitfunction asc( "J" )
	if scan = 37 then exitfunction asc( "K" )
	if scan = 38 then exitfunction asc( "L" )
	if scan = 39 then exitfunction asc( "Ö" )
	if scan = 40 then exitfunction asc( "Ä" )
	if scan = 43 then exitfunction asc( "$" )
	if scan = 44 then exitfunction asc( "Y" )
	if scan = 45 then exitfunction asc( "X" )
	if scan = 46 then exitfunction asc( "C" )
	if scan = 47 then exitfunction asc( "V" )
	if scan = 48 then exitfunction asc( "B" )
	if scan = 49 then exitfunction asc( "N" )
	if scan = 50 then exitfunction asc( "M" )
	if scan = 51 then exitfunction asc( "," )
	if scan = 52 then exitfunction asc( "." )
	if scan = 53 then exitfunction asc( "-" )
	
endfunction 0